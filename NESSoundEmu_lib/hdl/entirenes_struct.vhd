--
-- VHDL Architecture audiotest_lib.entireNES.struct
--
-- Created:
--          by - redacted.redacted (pc023)
--          at - 11:31:18 03/13/24
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2022.3 Built on 14 Jul 2022 at 13:56:12
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
library audiotest_lib; use audiotest_lib.booleanvectors.all;
USE ieee.math_real.all;
USE ieee.numeric_std.all;


ARCHITECTURE struct OF entireNES IS

   -- Architecture declarations

   -- Internal signal declarations
   SIGNAL Breqwrite          : boolean;
   SIGNAL accesswait         : std_logic;
   SIGNAL addr               : boolean_vector(15 DOWNTO 0);
   SIGNAL addr1312           : boolean_vector(1 DOWNTO 0);
   SIGNAL addrlow2           : boolean_vector(1 DOWNTO 0);
   SIGNAL addrlow5           : boolean_vector(4 DOWNTO 0);
   SIGNAL addrstd            : std_logic_vector(15 DOWNTO 0);
   SIGNAL alwaysOne          : std_logic;
   SIGNAL apuclk             : boolean;
   SIGNAL apuirq             : boolean;
   SIGNAL apumix             : boolean_vector(7 DOWNTO 0);
   SIGNAL apurd              : boolean;
   SIGNAL apuwr              : boolean;
   SIGNAL bkswwr             : boolean;
   SIGNAL controlportrd      : boolean;
   SIGNAL controlportwr      : boolean;
   SIGNAL cpuIRQ             : std_logic;
   SIGNAL cpuNMI             : std_logic;
   SIGNAL cpuRES             : std_logic;
   SIGNAL cpu_addr           : std_logic_vector(15 DOWNTO 0);
   SIGNAL cpu_data_in        : std_logic_vector(7 DOWNTO 0);
   SIGNAL cpu_data_out       : std_logic_vector(7 DOWNTO 0);
   SIGNAL cpuclk             : boolean;
   SIGNAL cpuportackread     : boolean;
   SIGNAL cpuportackwrite    : boolean;
   SIGNAL cpuportaddr        : boolean_vector(15 DOWNTO 0);
   SIGNAL cpuportdatafromdev : boolean_vector(7 DOWNTO 0);
   SIGNAL cpuportdatatodev   : boolean_vector(7 DOWNTO 0);
   SIGNAL cpuportreqread     : boolean;
   SIGNAL cpuportreqwrite    : boolean;
   SIGNAL data               : std_logic_vector(7 DOWNTO 0);
   SIGNAL dmcportackread     : boolean;
   SIGNAL dmcportaddr        : boolean_vector(15 DOWNTO 0);
   SIGNAL dmcportdatafromdev : boolean_vector(7 DOWNTO 0);
   SIGNAL dmcportdatatodev   : boolean_vector(7 DOWNTO 0);
   SIGNAL dmcportreqread     : boolean;
   SIGNAL memrd              : boolean;
   SIGNAL n163mix            : boolean_vector(7 DOWNTO 0);
   SIGNAL n163rd             : boolean;
   SIGNAL n163wr             : boolean;
   SIGNAL overlayvectors     : boolean;
   SIGNAL ratetimerrunout    : boolean;
   SIGNAL ratetimerwr        : boolean;
   SIGNAL rd                 : boolean;
   SIGNAL rw                 : std_logic;
   SIGNAL songramwr          : boolean;
   SIGNAL sync               : std_logic;
   SIGNAL tick               : std_logic;
   SIGNAL tickCPU            : boolean;
   SIGNAL vectorramwr        : boolean;
   SIGNAL vrc6addr           : boolean_vector(3 DOWNTO 0);
   SIGNAL vrc6mix            : boolean_vector(5 DOWNTO 0);
   SIGNAL vrc6rd             : boolean;
   SIGNAL vrc6wr             : boolean;
   SIGNAL wr                 : boolean;


   -- Component Declarations
   COMPONENT addrdecodereaddev
   PORT (
      addr          : IN     boolean_vector (15 DOWNTO 0);
      rd            : IN     boolean ;
      apurd         : OUT    boolean ;
      controlportrd : OUT    boolean ;
      memrd         : OUT    boolean ;
      n163rd        : OUT    boolean ;
      vrc6rd        : OUT    boolean 
   );
   END COMPONENT;
   COMPONENT addrdecodewritedev
   PORT (
      addr           : IN     boolean_vector (15 DOWNTO 0);
      clk            : IN     std_logic ;
      cpuIRQ         : IN     std_logic ;
      cpuNMI         : IN     std_logic ;
      cpuRES         : IN     std_logic ;
      data           : IN     std_logic_vector (7 DOWNTO 0);
      res_n          : IN     std_logic ;
      wr             : IN     boolean ;
      apuwr          : OUT    boolean ;
      bkswwr         : OUT    boolean ;
      controlportwr  : OUT    boolean ;
      n163wr         : OUT    boolean ;
      overlayvectors : OUT    boolean ;
      ratetimerwr    : OUT    boolean ;
      songramwr      : OUT    boolean ;
      vectorramwr    : OUT    boolean ;
      vrc6addr       : OUT    boolean_vector (3 DOWNTO 0);
      vrc6wr         : OUT    boolean 
   );
   END COMPONENT;
   COMPONENT apu
   PORT (
      addr       : IN     boolean_vector (4 DOWNTO 0);
      apuclk     : IN     boolean ;
      clk        : IN     std_logic ;
      cpuclk     : IN     boolean ;
      dmcdata    : IN     boolean_vector (7 DOWNTO 0);
      dmcreadack : IN     boolean ;
      rd         : IN     boolean ;
      res_n      : IN     std_logic ;
      wr         : IN     boolean ;
      dmcaddr    : OUT    boolean_vector (15 DOWNTO 0);
      dmcreadreq : OUT    boolean ;
      irq        : OUT    boolean ;
      mix        : OUT    boolean_vector (7 DOWNTO 0);
      data       : INOUT  std_logic_vector (7 DOWNTO 0)
   );
   END COMPONENT;
   COMPONENT controlPort
   PORT (
      clk           : IN     std_logic ;
      controlportrd : IN     boolean ;
      controlportwr : IN     boolean ;
      cpuclk        : IN     boolean ;
      res_n         : IN     std_logic ;
      resetCPU      : IN     boolean ;
      runCPU        : IN     boolean ;
      selectedSong  : IN     boolean_vector (7 DOWNTO 0);
      cpuRES        : OUT    std_logic ;
      status        : OUT    boolean_vector (7 DOWNTO 0);
      tickCPU       : OUT    boolean ;
      data          : INOUT  std_logic_vector (7 DOWNTO 0)
   );
   END COMPONENT;
   COMPONENT konamivrc6
   PORT (
      addr   : IN     boolean_vector (3 DOWNTO 0);
      clk    : IN     std_logic;
      cpuclk : IN     boolean;
      rd     : IN     boolean;
      res_n  : IN     std_logic;
      wr     : IN     boolean;
      mix    : OUT    boolean_vector (5 DOWNTO 0);
      data   : INOUT  std_logic_vector (7 DOWNTO 0)
   );
   END COMPONENT;
   COMPONENT loadabletimer
   GENERIC (
      maxval              : positive;
      requiredAddressbits : positive
   );
   PORT (
      addr        : IN     boolean_vector (requiredAddressbits-1 DOWNTO 0);
      clk         : IN     std_logic;
      data        : IN     std_logic_vector (7 DOWNTO 0);
      res_n       : IN     std_logic;
      tickclk     : IN     std_logic;
      wr          : IN     boolean;
      tick        : OUT    boolean;
      timerrunout : OUT    boolean
   );
   END COMPONENT;
   COMPONENT memarbitermx65interface
   GENERIC (
      addrw : integer := 16;
      dataw : integer := 8
   );
   PORT (
      clk                : IN     std_logic ;
      cpu_addr           : IN     std_logic_vector (15 DOWNTO 0);
      cpu_data_out       : IN     std_logic_vector (7 DOWNTO 0);
      cpuportackread     : IN     boolean ;
      cpuportackwrite    : IN     boolean ;
      cpuportdatatodev   : IN     boolean_vector (7 DOWNTO 0);
      res_n              : IN     std_logic ;
      rw                 : IN     std_logic ;
      sync               : IN     std_logic ;
      tickCPU            : IN     boolean ;
      cpu_data_in        : OUT    std_logic_vector (7 DOWNTO 0);
      cpuportaddr        : OUT    boolean_vector (15 DOWNTO 0);
      cpuportdatafromdev : OUT    boolean_vector (7 DOWNTO 0);
      cpuportreqread     : OUT    boolean ;
      cpuportreqwrite    : OUT    boolean ;
      tick               : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT memorieswrapper
   PORT (
      addr           : IN     boolean_vector (15 DOWNTO 0);
      bkswwr         : IN     boolean ;
      clk            : IN     std_logic ;
      overlayvectors : IN     boolean ;
      rd             : IN     boolean ;
      res_n          : IN     std_logic ;
      vectorramwr    : IN     boolean ;
      wr             : IN     boolean ;
      accesswait     : OUT    std_logic ;
      data           : INOUT  std_logic_vector (7 DOWNTO 0)
   );
   END COMPONENT;
   COMPONENT mx65withtick
   PORT (
      ce       : IN     std_logic;
      clock    : IN     std_logic;
      data_in  : IN     std_logic_vector (7 DOWNTO 0);
      irq      : IN     std_logic;
      nmi      : IN     std_logic;
      reset    : IN     std_logic;
      tick     : IN     std_logic;
      address  : OUT    std_logic_vector (15 DOWNTO 0);
      data_out : OUT    std_logic_vector (7 DOWNTO 0);
      rw       : OUT    std_logic;
      sync     : OUT    std_logic
   );
   END COMPONENT;
   COMPONENT namco163
   GENERIC (
      USETDM : boolean := true
   );
   PORT (
      addr    : IN     boolean_vector (1 DOWNTO 0);
      clk     : IN     std_logic ;
      cpuclk  : IN     boolean ;
      rd      : IN     boolean ;
      res_n   : IN     std_logic ;
      wr      : IN     boolean ;
      n163mix : OUT    boolean_vector (7 DOWNTO 0);
      data    : INOUT  std_logic_vector (7 DOWNTO 0)
   );
   END COMPONENT;
   COMPONENT nesmixer
   PORT (
      apumix  : IN     boolean_vector (7 DOWNTO 0);
      clk     : IN     std_logic ;
      n163mix : IN     boolean_vector (7 DOWNTO 0);
      res_n   : IN     std_logic ;
      vrc6mix : IN     boolean_vector (5 DOWNTO 0);
      mix     : OUT    boolean_vector (11 DOWNTO 0)
   );
   END COMPONENT;
   COMPONENT taktteilerboolean
   GENERIC (
      MAX : integer := 8
   );
   PORT (
      clk   : IN     std_logic ;
      res_n : IN     std_logic ;
      tick  : OUT    boolean 
   );
   END COMPONENT;
   COMPONENT twoportarbstdlogic
   GENERIC (
      addrw : integer := 16;
      dataw : integer := 8
   );
   PORT (
      Aaddr        : IN     boolean_vector (addrw-1 DOWNTO 0);
      Adatafromdev : IN     boolean_vector (dataw-1 DOWNTO 0);
      Areqread     : IN     boolean;
      Areqwrite    : IN     boolean;
      Baddr        : IN     boolean_vector (addrw-1 DOWNTO 0);
      Bdatafromdev : IN     boolean_vector (dataw-1 DOWNTO 0);
      Breqread     : IN     boolean;
      Breqwrite    : IN     boolean;
      accesswait   : IN     std_logic;
      clk          : IN     std_logic;
      res_n        : IN     std_logic;
      Aackread     : OUT    boolean;
      Aackwrite    : OUT    boolean;
      Adatatodev   : OUT    boolean_vector (dataw-1 DOWNTO 0);
      Backread     : OUT    boolean;
      Bdatatodev   : OUT    boolean_vector (dataw-1 DOWNTO 0);
      addr         : OUT    boolean_vector (addrw-1 DOWNTO 0);
      backwrite    : OUT    boolean;
      rd           : OUT    boolean;
      wr           : OUT    boolean;
      data         : INOUT  std_logic_vector (dataw-1 DOWNTO 0)
   );
   END COMPONENT;

   -- Optional embedded configurations
   -- pragma synthesis_off
   FOR ALL : addrdecodereaddev USE ENTITY audiotest_lib.addrdecodereaddev;
   FOR ALL : addrdecodewritedev USE ENTITY audiotest_lib.addrdecodewritedev;
   FOR ALL : apu USE ENTITY audiotest_lib.apu;
   FOR ALL : controlPort USE ENTITY audiotest_lib.controlPort;
   FOR ALL : konamivrc6 USE ENTITY audiotest_lib.konamivrc6;
   FOR ALL : loadabletimer USE ENTITY audiotest_lib.loadabletimer;
   FOR ALL : memarbitermx65interface USE ENTITY audiotest_lib.memarbitermx65interface;
   FOR ALL : memorieswrapper USE ENTITY audiotest_lib.memorieswrapper;
   FOR ALL : mx65withtick USE ENTITY audiotest_lib.mx65withtick;
   FOR ALL : namco163 USE ENTITY audiotest_lib.namco163;
   FOR ALL : nesmixer USE ENTITY audiotest_lib.nesmixer;
   FOR ALL : taktteilerboolean USE ENTITY audiotest_lib.taktteilerboolean;
   FOR ALL : twoportarbstdlogic USE ENTITY audiotest_lib.twoportarbstdlogic;
   -- pragma synthesis_on


BEGIN
   -- Architecture concurrent statements
   -- HDL Embedded Text Block 2 constantsandresetinersion1
   -- eb1 1 
   alwaysOne <= '1';
   --alwaysFalse <= false;
   --allfalse8 <= (others => false);
   --alwaysZero <= '0';   
   
   --cpuIRQ <= '0' when apuirq = true else '1'; 
   cpuIRQ <= '0' when ratetimerrunout else '1';
   cpuNMI <= '1';
   addrlow5 <= addr(4 downto 0);
   addr1312 <= addr(13 downto 12); 
   Breqwrite <= false;
   addrlow2 <= addr(1 downto 0);
   addrstd <= bool_vec2std_logic_vector(addr);                       


   -- Instance port mappings.
   rddeci : addrdecodereaddev
      PORT MAP (
         addr          => addr,
         rd            => rd,
         apurd         => apurd,
         controlportrd => controlportrd,
         memrd         => memrd,
         n163rd        => n163rd,
         vrc6rd        => vrc6rd
      );
   wdeci : addrdecodewritedev
      PORT MAP (
         addr           => addr,
         clk            => clk,
         cpuIRQ         => cpuIRQ,
         cpuNMI         => cpuNMI,
         cpuRES         => cpuRES,
         data           => data,
         res_n          => res_n,
         wr             => wr,
         apuwr          => apuwr,
         bkswwr         => bkswwr,
         controlportwr  => controlportwr,
         n163wr         => n163wr,
         overlayvectors => overlayvectors,
         ratetimerwr    => ratetimerwr,
         songramwr      => songramwr,
         vectorramwr    => vectorramwr,
         vrc6addr       => vrc6addr,
         vrc6wr         => vrc6wr
      );
   apui : apu
      PORT MAP (
         addr       => addrlow5,
         apuclk     => apuclk,
         clk        => clk,
         cpuclk     => cpuclk,
         dmcdata    => dmcportdatatodev,
         dmcreadack => dmcportackread,
         rd         => apurd,
         res_n      => res_n,
         wr         => apuwr,
         dmcaddr    => dmcportaddr,
         dmcreadreq => dmcportreqread,
         irq        => apuirq,
         mix        => apumix,
         data       => data
      );
   ctrlporti : controlPort
      PORT MAP (
         clk           => clk,
         controlportrd => controlportrd,
         controlportwr => controlportwr,
         cpuclk        => cpuclk,
         res_n         => res_n,
         resetCPU      => resetCPU,
         runCPU        => runCPU,
         selectedSong  => selectedSong,
         cpuRES        => cpuRES,
         status        => status,
         tickCPU       => tickCPU,
         data          => data
      );
   konvrc6 : konamivrc6
      PORT MAP (
         clk    => clk,
         res_n  => res_n,
         cpuclk => cpuclk,
         rd     => vrc6rd,
         wr     => vrc6wr,
         addr   => vrc6addr,
         data   => data,
         mix    => vrc6mix
      );
   U_0 : loadabletimer
      GENERIC MAP (
         maxval              => 2**16-1,
         requiredAddressbits => 2
      )
      PORT MAP (
         clk         => clk,
         res_n       => res_n,
         tickclk     => clk1M,
         data        => data,
         addr        => addrlow2,
         wr          => ratetimerwr,
         tick        => OPEN,
         timerrunout => ratetimerrunout
      );
   arbcpuif : memarbitermx65interface
      PORT MAP (
         clk                => clk,
         cpu_addr           => cpu_addr,
         cpu_data_out       => cpu_data_out,
         cpuportackread     => cpuportackread,
         cpuportackwrite    => cpuportackwrite,
         cpuportdatatodev   => cpuportdatatodev,
         res_n              => res_n,
         rw                 => rw,
         sync               => sync,
         tickCPU            => tickCPU,
         cpu_data_in        => cpu_data_in,
         cpuportaddr        => cpuportaddr,
         cpuportdatafromdev => cpuportdatafromdev,
         cpuportreqread     => cpuportreqread,
         cpuportreqwrite    => cpuportreqwrite,
         tick               => tick
      );
   memwrapi : memorieswrapper
      PORT MAP (
         addr           => addr,
         bkswwr         => bkswwr,
         clk            => clk,
         overlayvectors => overlayvectors,
         rd             => memrd,
         res_n          => res_n,
         vectorramwr    => vectorramwr,
         wr             => wr,
         accesswait     => accesswait,
         data           => data
      );
   mx65mod : mx65withtick
      PORT MAP (
         clock    => clk,
         reset    => cpuRES,
         tick     => tick,
         ce       => alwaysOne,
         data_in  => cpu_data_in,
         data_out => cpu_data_out,
         address  => cpu_addr,
         rw       => rw,
         sync     => sync,
         nmi      => cpuNMI,
         irq      => cpuIRQ
      );
   nam163 : namco163
      GENERIC MAP (
         USETDM => true
      )
      PORT MAP (
         addr    => addr1312,
         clk     => clk,
         cpuclk  => cpuclk,
         rd      => n163rd,
         res_n   => res_n,
         wr      => n163wr,
         n163mix => n163mix,
         data    => data
      );
   nesmix : nesmixer
      PORT MAP (
         apumix  => apumix,
         clk     => clk,
         n163mix => n163mix,
         res_n   => res_n,
         vrc6mix => vrc6mix,
         mix     => mix
      );
   apuclkdiv : taktteilerboolean
      GENERIC MAP (
         MAX => 16
      )
      PORT MAP (
         clk   => clk,
         res_n => res_n,
         tick  => apuclk
      );
   cpuclkdiv : taktteilerboolean
      GENERIC MAP (
         MAX => 8
      )
      PORT MAP (
         clk   => clk,
         res_n => res_n,
         tick  => cpuclk
      );
   arbi : twoportarbstdlogic
      GENERIC MAP (
         addrw => 16,
         dataw => 8
      )
      PORT MAP (
         Aaddr        => cpuportaddr,
         Adatafromdev => cpuportdatafromdev,
         Areqread     => cpuportreqread,
         Areqwrite    => cpuportreqwrite,
         Baddr        => dmcportaddr,
         Bdatafromdev => dmcportdatafromdev,
         Breqread     => dmcportreqread,
         Breqwrite    => Breqwrite,
         accesswait   => accesswait,
         clk          => clk,
         res_n        => res_n,
         Aackread     => cpuportackread,
         Aackwrite    => cpuportackwrite,
         Adatatodev   => cpuportdatatodev,
         Backread     => dmcportackread,
         Bdatatodev   => dmcportdatatodev,
         addr         => addr,
         backwrite    => OPEN,
         rd           => rd,
         wr           => wr,
         data         => data
      );

END struct;

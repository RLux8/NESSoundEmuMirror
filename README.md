# NESSoundEmu
This is a commit-flattened mirror of my  project repo on my universities private git server. The project was meant as a self-study along a VHDL-lecture and lab course.
## Overview
 This project strives to recreate components of the [NES Console](https://de.wikipedia.org/wiki/Nintendo_Entertainment_System) in order to play back .nsf song files on a [Cyclone V GX Starter Kit](https://www.terasic.com.tw/cgi-bin/page/archive.pl?Language=English&No=830). To achieve this, in addition of the reproduction of the NES hardware, an interface for the SSM2603 audio codec present on the starter kit was implemented.

All of the hardware description was done in VHDL using the HDL Designer tool.
 
## Sample recording from FPGA board


https://github.com/RLux8/NESSoundEmuMirror/assets/72990534/34cfe8cc-1baf-49e1-b940-ae74aabecac3


## Getting started / Loading the demo configuration
The demo configuration files are located in the NESSoundEmu_lib/qis/@n@e@s@playertoplevel_struct library. You can use Quartus to either configure the FPGA temporarily using the NESPlayertoplevel.sof file or write the output_file.pof to the Flash of the FPGA board to keep the configuration between powercycles.

If you want to work on this project it should be sufficient to import all .vhd files and subfolders in the NESSoundEmu_lib/hdl folder into a quartus project and setting nesplayertoplevel_struct.vhd as the design root. This was not tested though since the project was always worked on using the HDL Designer.

## File Overview
The hardware design part of this project was achieved using the HDL Designer Tool while synthesis was done using Quartus. These files are located in the NESSoundEMu_lib folder:<br>
- hdl/ - VHDL code  (also contains links to the memory init files)
- hds/ - all files related to graphical blocks/components created in HDL designer
- qis/ - some autogenerated files for hardware synthesis uisng Intel Quartus
- questasim/ - some autogenerated files for the Questasim VHDL simulator (also contains links to the memory init files)
- questasim_lint/ - autogenerated ... nothing interesting here
  
 Some helper scripts are written in Python and the code responsible for the sound initialisation/playback is pure 6502 assembly. 
 Those files are contained in the helpers/ folder: <br>
 
- entireNESTBhelpers/ - files related to be able to convert output files of the main testbench file into audio files to listen to.
- py6502/ - slightly modified version of the [py6502 assembler/simulator](https://github.com/dj-on-github/py6502) (changes are py2->py3 and support for label offsets) used by compileplayer[multiple].py
- songromnsfs/ - the nsf files which will be combined into the memory file containing the song roms
- bin2mif-master/ - a clone of https://github.com/brNX/bin2mif for initial testing of single song ROMs.
- compileplayer[multiple].py - Assembles player6502[multiplesongs].asm into bootROM4kx8[multiple].mif
- createSongROM.py - Takes files in songromnsfs and combines them into songROMcontentsmultiple.mif


## SSM2603 audio codec
The [SSM2603](https://www.analog.com/en/products/ssm2603.html) audio codec provides an ADC, a DAC as well as some digital signal processing. Data is exchanged in a serial manner with multiple protocol options, one of them being I2S which was used here. In this project, only the DAC portion of the chip is utilised for outputting the serial PCM data on the line out port of the starter kit. The I2S transciever used was copied from https://forum.digikey.com/t/i2s-transceiver-vhdl/12845.

Prior to using the codec it has to be configured over I2C to set the sample rate and the serial protocol used. 
This configuration functionality was split into three components, one of them being a third-party [I2C master](https://forum.digikey.com/t/i2c-master-vhdl/12797). The other two components are a register writer finite state machine which writes provided data into a register determined by a provided register address using the I2C master. The third component is the top level control for the codec, writing the correct configuration data into the registers with the required timing and in the correct order using the other two components.


## Reproduced NES hardware
 As mentioned above all components of the NES console required for playback of .nsf files were recreated in VHDL or pulled from other projects.
 These components are (names dont necessarily match the ones assigned in HDL Designer):
- mx65tick - a slightly modified [mx65 6502 core](https://github.com/Steve-Teal/mx65) with an added boolean tick signal to run the processor with a slower clock which is used as the main CPU
- memory blocks: the system ram blocks as well as the large block RAM containing the .nsf files (those were autogenerated using the Quartus IP Wizard)
- a bankswitcher as specified in the [.nsf file specification](https://www.nesdev.org/wiki/NSF) with an additional configurable song ROM offset
- an arbiter/access multiplexer to allow both the CPU and the dpcm channel to access the system memory
- a play rate timer to tell the CPU to call the play routine again
- [NES APU](https://www.nesdev.org/wiki/APU) - the sound subcircuit contained in the 2a03 main chip of the NES. It contains
  * two square channels with length and sweep units
  * a triangle channel, also with a length unit
  * a noise channel which outputs noise from a LFSR-PRNG
  * a dpcm channel for delta modulated samples
  * a frame counter for generating interrupts and slow clocks to the note channels
  * a linear interpolation of the nonlinear DAC mixer present on the 2a03
  
Also, some expansion chips were implemented:
- [N163](https://www.nesdev.org/wiki/Namco_163_audio) - an implementation of the Namco 163 chip sound system which provides up to eight variable waveform channels using its built-in 128 bytes of wave ram
- [VRC6](https://www.nesdev.org/wiki/VRC6_audio) - an implementation of the Konami VRC6 chip sound system which provides:
  * two square channels
  * a sawtooth channel

## nsf storage ROM
A total of 384 kB of the on chip block RAM of the FPGA used on the Cyclone V GX Starter kit is reserved for nsf file storage. Since this block RAM is initialised during configuration of the FPGA it provides a simple way of providing nonvolatile memory for this purpose and is called a ROM in this project since its contents dont change during system operation. To allow for the playback of multiple .nsf files without changing the song block ROMs contents, a crude management scheme for the song ROM is employed.

The first byte of the song ROM contains the number of .nsf files which are contained in the ROM. After this byte, 32 bit words determine the offset of the individual .nsf file contents in the song ROM. Follwing the offset words is the content of the first .nsf file then the second and so on. 

The .nsf file to played back can be selected using the slider switches present on the Cyclone V board. 

## 6502 player code
.nsf (NES Sound Format) files can be created by exporting them from chiptune trackers such as FamiTracker or Furnace. These files contain 6502 machine code after a small header with metadata. To play a song, the main player program has to setup the system memory by zeroing it out and then call an INIT routine in the machine code section (offset is given in the header) . At a rate also given in the nsf header, the main player code is expected to call a PLAY routine (also in the machine code section, offset also given in header). In addition to these tasks, the player code also copies the .nsfs file header to keep it accessible even when playing. This header copy is required since nsf playback requires the .nsf file contents to be mapped into the memory into the address space in a certain way which might make the nsf file header inaccessible. The memory mapping is setup as given in the nsf file header by writing to the memory-mapped registers of the bank switcher unit. 

## Helpful Documentation
 The [NESdev wiki](https://www.nesdev.org/wiki/Nesdev_Wiki) was of great help when working on this project. Also the source code of [NSFPlay](https://github.com/bbbradsmith/nsfplay) was occasionally used to verify the NESdev Wiki information.
 
## Possible improvements
- more expansion chips (Konami VRC7, FDS, MMC5...)
- finish the sd card interface branch for extended nsf storage space
- change the NES end mixer so it adjusts the volume of all submixes depending on the enabled expansion chips 
- add some dmc direct reload pop supressor?
- add some low/highpass filters as present in the NES
